\documentclass[12pt]{article}
\usepackage{sbc-template}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{times,amsmath,epsfig}
\usepackage{graphicx,url}
  \makeatletter
  \newif\if@restonecol
  \makeatother
  \let\algorithm\relax
  \let\endalgorithm\relax
\usepackage[lined,algonl,ruled]{algorithm2e}
\usepackage{multirow}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{hyperref}

\sloppy

\title{Redes de Computadores \\ Trabalho Prático 1 \\
\huge{Cliente e servidor em Sockets}}
\date{November 22, 1963}


\author{André Taiar Marinho Oliveira}


\address{Departamento de Ciência da Computação -- Universidade Federal de Minas Gerais (UFMG)
\email{taiar@dcc.ufmg.br}
\\
\\ Outubro de 2016
}

\begin{document}

\maketitle

\begin{resumo}
O problema tratado nesse trabalho é o de comunicação entre softwares cliente e
servidor através de sockets em redes de computadores. Para isso, foi definido um
protocolo de comunicação para um problema bem específico: coletar tempos de
atletas das olimpíadas e retornar em ordem de chegada ou individualmente (quando
passado o parâmetro da colocação do atleta). Foi feita a implementação dos dois
programas (cliente e servidor) de forma modularizada e um Makefile para orientar
a compilação do projeto.
\end{resumo}

\section{Implementação}
O trabalho foi implementado em C++ para que eu pudesse me aproveitar melhor dos
módulos de forma orientada a objetos. Foram implementados dois programas,
cliente e servidor, de forma modularizada (cada módulo é uma classe
basicamente). Os módulos implementados bem como suas funções são descritos
abaixo.

\subsection{Token}
A classe Token é responsável pela leitura da entrada fornecida pelo cliente.
Basicamente ela separa a string fornecida por cada linha da entrada em
sub-strings de forma que possamos fazer a leitura dos inputs fornecidos. O
cabeçalho da classe é fornecido a seguir:

\begin{verbatim}
  #ifndef __TOKEN_H
  #define __TOKEN_H TOKEN

  #define DELIMITER " "

  #include <string>
  #include <vector>

  class Token {
  public:
    Token(std::string);
    std::string getToken();
    std::string getNextToken();
    unsigned int total();
    int getCurrent();

  private:
    std::string input;
    std::vector<std::string> tokens;
    int current;

    void tokenize();
  };

  #endif
\end{verbatim}

\subsection{Tempo}
A classe Tempo é responsável por encapsular todo o processamento que precisamos
fazer sobre o input de tempo no sistema. Suas principais funções são:

\begin{enumerate}
  \item Instanciar o tempo à partir de uma string fornecida pela entrada;
  \item Comparar se um tempo fornecido é maior ou menor que outro tempo.
\end{enumerate}

O cabeçalho da classe é fornecido a seguir:

\begin{verbatim}
  #ifndef __TEMPO_H
  #define __TEMPO_H TEMPO

  #include <iostream>
  #include <vector>
  #include <sstream>
  #include <string>

  #include <cctype>
  #include <cstdlib>

  #include "token.h"

  using namespace std;

  class Tempo {
  public:
    int hours;
    int minutes;
    int seconds;
    int milisseconds;

    Tempo();
    Tempo(int, int, int, int);
    int compare(Tempo);
    Tempo* setFromString(char[]);
    string toString();
    void print();
    bool biggerThan(Tempo*);
    bool smallerOrEqualThan(Tempo*);

  private:
    void parseUnit(string);
    bool isNumber(char);
    void setTimeUnit(string, string);
    int toPseudoMs();
  };

  #endif
\end{verbatim}

\subsection{Servidor}

A classe Servidor é responsável por encapsular toda a implementação do software
servidor e a utilização de sockets para isso. Também contém a implementação do
método $main$ da aplicação servidor. A intenção dela é abstrair as arestas
trazidas pelas bibliotecas de sockets em C e implementar métodos que possam ser
mais fáceis de usar.

Um bom exemplo de encapsulamento de um comportamento mais complicado seria o
método a função $Servidor::sendToClient$ que envia para o cliente já conectado
uma string qualquer com uma quebra de linha ao final. Toda a comunicação que é
feita dos servidor para o cliente neste trabalho utiliza esse método.

Uma outra vantagem em trabalhar com C++ neste projeto foi a maior facilidade de
lidar com as strings ao invés de cadeias de caracteres.

O cabeçalho da classe Servidor é fornecido a seguir:

\begin{verbatim}
  #ifndef __SERVIDOR_H
  #define __SERVIDOR_H SERVIDOR

  #include <vector>
  #include <string>
  #include <cstdlib>
  #include <cstring>
  #include <cstdio>
  #include <unistd.h>

  #include <sys/socket.h>
  #include <arpa/inet.h>

  #include "tempo.h"

  struct sockaddr;

  void logexit(const char*);
  void fill(const struct sockaddr *addr, char *line);

  class Servidor {
  public:
    Servidor(int);
    void logexit(const char*);
    void fill(const struct sockaddr*, char*);
    void run();
    void pushTime(char[]);
    void getPosition(char[]);
    void dumpTimes();
    void shutdown();
    static int compare(const void*, const void*);
    void parse(char[]);
    void sendToClient(string);

  private:
    int porta;
    int s;
    int r;
    std::vector<Tempo*> tempos;
    Tempo* returnThePosition(unsigned int);
  };

  #endif
\end{verbatim}

\end{document}
